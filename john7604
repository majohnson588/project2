死循环实例
int main()
{
    int i = 0;
    int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    //VC6.0 环境下 <=10 就死循环了
    //gcc 编辑器 <=11 就死循环了
    //VS2013      <=12 死循环
    for(i = 0; i <= 11; i++)
   {
           printf("hehe\n");
           arr[ i ] = 0;
    }
    system("pause");
    return 0;
}

结构的声明
    struct tag
    {
     member-list;
    }variable-list;
  //如描述一个学生-一些数据
  //名字
  //年龄
  //电话
  //性别

  //struct 结构体关键字    Stu - 结构体标签    struct Stu - 结构体类型
  struct Stu
  {
        //成员变量
        char name[20];
        short age;                                                  int                                        图纸
        char tele[12];              定义结构体类型
        char sex[5];
  }s1,s2,s3;//s1,s2,s3                 是三个全局的结构体变量                           盖房子
 
typedef struct Stu
{
    //成员变量
    char name[20];//名字
    short age;//年龄
    char tele[12];//电话
    char sex[5];//性别
    char id[20];//学号
 }s2;//类型(分号不能丢)

 int main()                                                                                    
{
 struct Stu s1 = {"旺财", 20, "15249287076", "保密"};                                           创建结构体变量
 Stu s2 = {"张三", 20 , "15249287076", "男"};//局部变量  
 return 0;                                                        int a = 10                                 房子       
}

结构成员的类型
结构的成员可以是标量、数组、指针，甚至是其他结构体

结构体变量的定义和初始化
有了结构体类型，那如何定义变量，其实很简单
struct Point
{
        int x;
        int y;
}p1;                                             //声明类型的同时定义变量p1
struct Point p2;                           //定义结构体变量p2

//初始化：定义变量的同时赋初值。
struct Point p3  =  {x , y};

struct Stu                                    //类型声明

struct S
{
      int a;
      char c;
      char arr[20];
      double d;
};

struct T
{
      char ch[10];
      struct S s;
      char *pc;
};

int main()
{
      char arr[ ] = "hello bit\n";
      struct T t = {"hehe",  {100, 'w', "hello world", 3.14}, arr};//结构体的嵌套
      printf("%s\n", t. ch);//hehe
      printf("%s\n", t. s. arr);//hello world
      printf("%lf\n", t .s .d);//3.14
      printf("%s\n", t .pc);//hello bit
      return 0;
}

结构体的访问
typedef struct Stu
{
      //成员变量
      char name[20];
      short age;
      char tele[12];
      char sex[5];
}Stu;//重命名，否则是struct Stu

void Print1(Stu tmp)
{
    printf("name: %s\n", tmp.name);
    printf("age:    %d\n", tmp.age);
    printf("tale:    %s\n", tmp.tele);
    printf("sex:    %s\n", tmp.sex);
}
void Print2(Stu* ps)
{
    printf("name: %s\n", ps->name);
    printf("age:   %d\n", ps->age);
    printf("tale:   %s\n", ps->tele);
    printf("sex:   %s\n", ps->sex);
}      
int main()
{
      Stu s = {"李四", 40, "15598886688", "男"};
      //打印结构体数据
      //Print1和Print2 哪个更好？
      Print1(s);
      Print2(&s);//用指针接收
      //Print2更好，函数传参时，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降
     //结论：结构体传参的时候，要传结构体的地址
      return 0;
}

数据存储
Exercise1:
//输出什么
#include <stdio.h>
int main()
{
    char a = -1;
    //10000000000000000000000000000001
    //11111111111111111111111111111110
    //11111111111111111111111111111111
    //11111111
    //
    signed char b = -1;
    //11111111
    //
    unsigned char c = -1;//无符号
    //00000000000000000000000011111111整形提升
    //255
    printf("a=%d",b=%d,c=%d",a,b,c);//-1,-1,255
    return 0;
}

Exercise2:
//输出什么
#include <stdio.h>
int main()
{
      char a = -128;
      //10000000000000000000000010000000
      //11111111111111111111111101111111
      //11111111111111111111111110000000-补码
      //10000000首位为1，前面补1
      //11111111111111111111111110000000-补码（答案）
      //无符号数补码与原码相同
      printf("%u\n", a);
      //%d - 打印十进制的有符号数字
      //%u - 打印十进制的无符号数字
      return 0;
}

Exercise3:
int main()
{
      int i = -20;
      unsigned int j = 10;
      printf("%d\n", i+j); 
      //按照补码的形式进行运算，最后格式化成为有符号整数
      //10000000 00000000 00000000 00010100
      //11111111 11111111 11111111 11101011
      //11111111 11111111 11111111 11101100 - 补码
      //00000000 00000000 00000000 00001010 - 补码
      //11111111 11111111 11111111 11110110 - 结果
        11111111 11111111 11111111 11110101 
        10000000 00000000 00000000 00001010 - 答案是-10
        return 0;
}

Exercise4:
#include<windows.h>
int main()
{
      unsigned int i;
      for(i = 9;i >= 0;i--)
      {
             printf("%d\n", i);
      }
      return 0;
 }
 output:
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
 4294967295(-1的无符号数是一个超大数)
 4294967294
 4294967293
 4294967292
 ......
 
 Exercise5:
 //求下列输出
 int main()
 {
     char a[1000];
     int i;
     for(i = 0; i<1000; i++)
     {
         a[i] = -1 - i;
     }
     printf("%d", strlen(a));
     return 0;
  }
  答案是255
  有符号char存储范围是-127-128
  
  Exercise6:
  unsigned char i = 0;
  int main()
  {
      for(i = 0; i <= 255; i++)
      {
          printf("Hello world");
      }
      return 0;
   }
   答案是死循环
  
  指针进阶
  Exercise1:
  int main()
  {
        char arr1[] = "abcdef";
        char arr2[] = "abcdef";
        char* p1 = "abcdef";
        char *p2 = "abcdef";
        if(arr1 == arr2)
        {
            printf("hello\n");
        }
        else
        {
            printf("hi\n");
        }
        if(p1 == p2)
        {
            printf("hello\n");
        }
        else
        {
            printf("hi");
        }
        return 0;
  }
  output:
  hi
  hello
  
  Exercise2:
  //对以下指针数组和数组指针进行解引用操作
  int main()
  {
        char* arr[5];
        char* (*pa)[5] = &arr;
        
        int arr2[10] = { 0 };
        int (*pa2)[10] = &arr2;
        
        return 0;
   }

指针数组
Example1:
    int main()
   {
        int a = 10;
        int b = 20;
        int c = 30;
        int d = 40;
        int* arr[4] = {&a, &b, &c, &d};
        int i = 0;
        for(i = 0; i < 4; i++)
        {
                printf("%d ", *(arr[i]));
        }
        return 0;
   }
   
Example2:
  int main()
 {
      int arr1[ ] = { 1, 2, 3, 4, 5 };
      int arr2[ ] = { 2, 3, 4, 5, 6 };
      int arr3[ ] = { 3, 4, 5, 6, 7 };
      int* parr[ ] = { arr1, arr2, arr3 };
      int i = 0;
      for(i = 0;i < 3; i++)
      {
            int j = 0;
            for(j = 0;j < 5; i++)
            {
                  printf("%d ",*(parr[i] + j));
                  //printf("%d ",parr[i][j]);
            }
            printf("\n");
       }
      return 0;
 }
 
 数组指针
 Example1:
 形参写成指针的形式
 void print1(int* arr, int sz)
 {
     int i = 0;
     for(i = 0; i < sz; i++)
     {
         printf("%d ",arr[i]);
         //printf("%d ",*(arr+i));
     }
     printf("\n");
 }
 
 //用数组指针接收(不是推荐的写法)
 //void print1(int (*p)[10], int sz)
 //{
 //    int i = 0;
 //    for(i = 0; i < sz; i++)
 //    {   
 //        *p相当于数组名，数组名又是首元素的地址，所以*p就是&arr[0]    
 //        printf("%d ",*(*p + i));
 //    }
 //}
 
 int main()
 {
     int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
     //写一个函数打印arr数组的内容
     int sz = sizeod(arr) / sizeof(arr[0]);
     print1(arr,sz);
     //print1(&arr,sz);
     return 0;
 }

Example2:
//void print2(int arr[3][5], int c, int r)
void print2(int (*p)[5], int c, int r)
{
    int i = 0;
    for(i = 0; i < c; i++)
    {
        int j = 0;
        for(j = 0; j < r; j++)
        {   
            //p+i是指向第i行的
            //*(p+i)相当于拿到了第i行，也相当于第i行的数组名
            //数组名表示首元素的地址，*(p+i)就是第i行第一个元素的地址
            printf("%d ",*(*(p+i)+j));
            //printf("%d ", p[i][j]);
        }
        //arr[i]
        //*(arr+i)
        //
        //arr[i][j]
        //*(arr+i)[j]
        //*(*(arr+i)+j)
         printf("\n");
    }
}
int main()
{
    int arr[3][5] = { {1,2,3,4.5},{2,3,4,5,6},{3,4,5,6,7}};
    //int (*ptr)[3][5] = &arr;
    //写一个函数，打印arr数组
    print2(arr, 3, 5);//二维数组中首元素地址表示的是第一行的地址
    return 0;
}

Practice1:
写一个函数统计二进制中1的个数
A1:
int Func1(int n)
{
   int i = 0;
   int count = 0;
   for(i=0; i<12; i++)
   {
       if({(n>>i) & 1) == 1)
       {
           count++;
       }
   }
    return count;
}

A2:
int Func2(int n)
{
    unsigned int m = n;
    int count = 0;
    while(m)
    {
        if(m % 2 == 1)
        count++;
        
        m /= 2;
    }
    return count;
}

A3:
int Func3(int n)
{
    int count = 0;
    while(n)
    {
        n = n & (n-1);
        //每次去掉一个“1”
        count++;
    }
    return count;
}

Practice2:
写一个函数判断n是否为2的幂次方
void Fun(int n)
{
    if(n & (n-1) == 0)
    printf("YES");
    else
    printf("NO");
}

Practice3:
求两个二进制数不同位的个数
A1:
int main()
{
    int m = 0;
    int n = 0;
    scanf("%d %d",&m ,&n);
    int i = 0;
    int diff = 0;
    for(i=0; i<32; i++)
    {
        if(((m>>1) & 1) != ((n>>1) & 1))
        {
            diff++;
        }
    }
    printf("%d\n",diff);
    return 0;
 }
 A2:
 int main()
 {
     int m = 0;
     int n = 0;
     scanf("%d %d", &m , &n);
     int i;
     int diff;
     int tmp = m^n;
     while(tmp)
     {
         tmp = tmp & (tmp-1);
         diff++;
     }
     printf("%d\n",diff);
     return 0;
 }
 
 Practice4:
 打印整数二进制的奇数位和偶数位
 int main()
 {
 
 
