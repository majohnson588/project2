死循环实例
int main()
{
    int i = 0;
    int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    //VC6.0 环境下 <=10 就死循环了
    //gcc 编辑器 <=11 就死循环了
    //VS2013      <=12 死循环
    for(i = 0; i <= 11; i++)
   {
           printf("hehe\n");
           arr[ i ] = 0;
    }
    system("pause");
    return 0;
}

结构的声明
    struct tag
    {
     member-list;
    }variable-list;
  //如描述一个学生-一些数据
  //名字
  //年龄
  //电话
  //性别

  //struct 结构体关键字    Stu - 结构体标签    struct Stu - 结构体类型
  struct Stu
  {
        //成员变量
        char name[20];
        short age;                                                  int                                        图纸
        char tele[12];              定义结构体类型
        char sex[5];
  }s1,s2,s3;//s1,s2,s3                 是三个全局的结构体变量                           盖房子
 
typedef struct Stu
{
    //成员变量
    char name[20];//名字
    short age;//年龄
    char tele[12];//电话
    char sex[5];//性别
    char id[20];//学号
 }s2;//类型(分号不能丢)

 int main()                                                                                    
{
 struct Stu s1 = {"旺财", 20, "15249287076", "保密"};                                           创建结构体变量
 Stu s2 = {"张三", 20 , "15249287076", "男"};//局部变量  
 return 0;                                                        int a = 10                                 房子       
}

结构成员的类型
结构的成员可以是标量、数组、指针，甚至是其他结构体

结构体变量的定义和初始化
有了结构体类型，那如何定义变量，其实很简单
struct Point
{
        int x;
        int y;
}p1;                                             //声明类型的同时定义变量p1
struct Point p2;                           //定义结构体变量p2

//初始化：定义变量的同时赋初值。
struct Point p3  =  {x , y};

struct Stu                                    //类型声明

struct S
{
      int a;
      char c;
      char arr[20];
      double d;
};

struct T
{
      char ch[10];
      struct S s;
      char *pc;
};

int main()
{
      char arr[ ] = "hello bit\n";
      struct T t = {"hehe",  {100, 'w', "hello world", 3.14}, arr};//结构体的嵌套
      printf("%s\n", t. ch);//hehe
      printf("%s\n", t. s. arr);//hello world
      printf("%lf\n", t .s .d);//3.14
      printf("%s\n", t .pc);//hello bit
      return 0;
}

结构体的访问
typedef struct Stu
{
      //成员变量
      char name[20];
      short age;
      char tele[12];
      char sex[5];
}Stu;//重命名，否则是struct Stu

void Print1(Stu tmp)
{
    printf("name: %s\n", tmp.name);
    printf("age:    %d\n", tmp.age);
    printf("tale:    %s\n", tmp.tele);
    printf("sex:    %s\n", tmp.sex);
}
void Print2(Stu* ps)
{
    printf("name: %s\n", ps->name);
    printf("age:   %d\n", ps->age);
    printf("tale:   %s\n", ps->tele);
    printf("sex:   %s\n", ps->sex);
}      
int main()
{
      Stu s = {"李四", 40, "15598886688", "男"};
      //打印结构体数据
      //Print1和Print2 哪个更好？
      Print1(s);
      Print2(&s);//用指针接收
      //Print2更好，函数传参时，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降
     //结论：结构体传参的时候，要传结构体的地址
      return 0;
}

数据存储
Exercise1:
//输出什么
#include <stdio.h>
int main()
{
    char a = -1;
    //10000000000000000000000000000001
    //11111111111111111111111111111110
    //11111111111111111111111111111111
    //11111111
    //
    signed char b = -1;
    //11111111
    //
    unsigned char c = -1;//无符号
    //00000000000000000000000011111111整形提升
    //255
    printf("a=%d",b=%d,c=%d",a,b,c);//-1,-1,255
    return 0;
}

Exercise2:
//输出什么
#include <stdio.h>
int main()
{
      char a = -128;
      //10000000000000000000000010000000
      //11111111111111111111111101111111
      //11111111111111111111111110000000-补码
      //10000000首位为1，前面补1
      //11111111111111111111111110000000-补码（答案）
      //无符号数补码与原码相同
      printf("%u\n", a);
      //%d - 打印十进制的有符号数字
      //%u - 打印十进制的无符号数字
      return 0;
}

Exercise3:
int main()
{
      int i = -20;
      unsigned int j = 10;
      printf("%d\n", i+j); 
      //按照补码的形式进行运算，最后格式化成为有符号整数
      //10000000 00000000 00000000 00010100
      //11111111 11111111 11111111 11101011
      //11111111 11111111 11111111 11101100 - 补码
      //00000000 00000000 00000000 00001010 - 补码
      //11111111 11111111 11111111 11110110 - 结果
        11111111 11111111 11111111 11110101 
        10000000 00000000 00000000 00001010 - 答案是-10
        return 0;
}

Exercise4:
#include<windows.h>
int main()
{
      unsigned int i;
      for(i = 9;i >= 0;i--)
      {
             printf("%d\n", i);
      }
      return 0;
 }
 output:
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
 4294967295(-1的无符号数是一个超大数)
 4294967294
 4294967293
 4294967292
 ......
 
 Exercise5:
 //求下列输出
 int main()
 {
     char a[1000];
     int i;
     for(i = 0; i<1000; i++)
     {
         a[i] = -1 - i;
     }
     printf("%d", strlen(a));
     return 0;
  }
  答案是255
  有符号char存储范围是-127-128
  
  Exercise6:
  unsigned char i = 0;
  int main()
  {
      for(i = 0; i <= 255; i++)
      {
          printf("Hello world");
      }
      return 0;
   }
   答案是死循环
  
  指针进阶
  Exercise1:
  int main()
  {
        char arr1[] = "abcdef";
        char arr2[] = "abcdef";
        char* p1 = "abcdef";
        char *p2 = "abcdef";
        if(arr1 == arr2)
        {
            printf("hello\n");
        }
        else
        {
            printf("hi\n");
        }
        if(p1 == p2)
        {
            printf("hello\n");
        }
        else
        {
            printf("hi");
        }
        return 0;
  }
  output:
  hi
  hello
  
  Exercise2:
  //对以下指针数组和数组指针进行解引用操作
  int main()
  {
        char* arr[5];
        char* (*pa)[5] = &arr;
        
        int arr2[10] = { 0 };
        int (*pa2)[10] = &arr2;
        
        return 0;
   }

指针数组
Example1:
    int main()
   {
        int a = 10;
        int b = 20;
        int c = 30;
        int d = 40;
        int* arr[4] = {&a, &b, &c, &d};
        int i = 0;
        for(i = 0; i < 4; i++)
        {
                printf("%d ", *(arr[i]));
        }
        return 0;
   }
   
Example2:
  int main()
 {
      int arr1[ ] = { 1, 2, 3, 4, 5 };
      int arr2[ ] = { 2, 3, 4, 5, 6 };
      int arr3[ ] = { 3, 4, 5, 6, 7 };
      int* parr[ ] = { arr1, arr2, arr3 };
      int i = 0;
      for(i = 0;i < 3; i++)
      {
            int j = 0;
            for(j = 0;j < 5; i++)
            {
                  printf("%d ",*(parr[i] + j));
            }
            printf("\n");
       }
      return 0;
 }
